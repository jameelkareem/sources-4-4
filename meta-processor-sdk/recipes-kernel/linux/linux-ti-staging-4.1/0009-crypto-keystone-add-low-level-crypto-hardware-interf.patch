From c1301b5d39d9d29266c08f8ee0d74ccc4522066b Mon Sep 17 00:00:00 2001
From: Vitaly Andrianov <vitalya@ti.com>
Date: Thu, 4 Feb 2016 12:36:29 -0500
Subject: [PATCH 09/23] crypto: keystone: add low level crypto hardware
 interface code

This patch adds the driver support for keystone SA in sideband mode.

The driver registers algorithm implementations in the Kernel crypto
framework. Since the primary use case in kernel is to enable HW offload
of IPSec ESP crypto operations, the driver is currently supporting only
authenticated encryption (AEAD) mode. Following algorithms are currently
supported:

 - authenc(hmac(sha1),cbc(aes))
 - authenc(hmac(sha1),cbc(des3_ede))
 - authenc(hmac(sha1),ecb(cipher_null))

The driver is based on TI SA Low Level Driver (LLD).
In order to simplify maintainability and easy porting of future LLD
version the kernel driver code is kept as much close to LLD as possible.

To make the driver more readable it was split into several commits.
This is the first commit which introduces the header files and
keystone-sa-lld.c. The keystone-sa-lld.c re-implements/copies number of
helper functions provided by LLD.

Signed-off-by: Sandeep Nair <sandeep_n@ti.com>
Signed-off-by: Tinku Mannan <tmannan@ti.com>
Signed-off-by: Hao Zhang <hzhang@ti.com>
Signed-off-by: Vitaly Andrianov <vitalya@ti.com>
---
 drivers/crypto/Kconfig           |  17 ++
 drivers/crypto/Makefile          |   2 +
 drivers/crypto/keystone-sa-hlp.h | 399 ++++++++++++++++++++++++++++++++++++
 drivers/crypto/keystone-sa-lld.c | 429 +++++++++++++++++++++++++++++++++++++++
 drivers/crypto/keystone-sa.h     | 327 +++++++++++++++++++++++++++++
 5 files changed, 1174 insertions(+)
 create mode 100644 drivers/crypto/keystone-sa-hlp.h
 create mode 100644 drivers/crypto/keystone-sa-lld.c
 create mode 100644 drivers/crypto/keystone-sa.h

diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index 6696c13..f7e2528 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -276,6 +276,23 @@ config CRYPTO_DEV_OMAP_DES
 	  the ECB and CBC modes of operation supported by the driver. Also
 	  accesses made on unaligned boundaries are also supported.
 
+config CRYPTO_DEV_KEYSTONE
+	tristate "Support for TI Keystone security accelerator"
+	depends on ARCH_KEYSTONE
+	select ARM_CRYPTO
+	select CRYPTO_AES
+	select CRYPTO_AES_ARM
+	select CRYPTO_SHA1
+	select CRYPTO_MD5
+	select CRYPTO_ALGAPI
+	select CRYPTO_AUTHENC
+	select HW_RANDOM
+	default m if ARCH_KEYSTONE
+	help
+	  Keystone devices include a security accelerator engine that may be
+	  used for crypto offload.  Select this if you want to use hardware
+	  acceleration for cryptographic algorithms on these devices.
+
 config CRYPTO_DEV_PICOXCELL
 	tristate "Support for picoXcell IPSEC and Layer2 crypto engines"
 	depends on ARCH_PICOXCELL && HAVE_CLK
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 3afad7b..0d9f038 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -8,6 +8,8 @@ obj-$(CONFIG_CRYPTO_DEV_GEODE) += geode-aes.o
 obj-$(CONFIG_CRYPTO_DEV_HIFN_795X) += hifn_795x.o
 obj-$(CONFIG_CRYPTO_DEV_IMGTEC_HASH) += img-hash.o
 obj-$(CONFIG_CRYPTO_DEV_IXP4XX) += ixp4xx_crypto.o
+obj-$(CONFIG_CRYPTO_DEV_KEYSTONE) += keystone-sa-driver.o
+keystone-sa-driver-objs := keystone-sa-lld.o
 obj-$(CONFIG_CRYPTO_DEV_MV_CESA) += mv_cesa.o
 obj-$(CONFIG_CRYPTO_DEV_MXS_DCP) += mxs-dcp.o
 obj-$(CONFIG_CRYPTO_DEV_NIAGARA2) += n2_crypto.o
diff --git a/drivers/crypto/keystone-sa-hlp.h b/drivers/crypto/keystone-sa-hlp.h
new file mode 100644
index 0000000..a68f963
--- /dev/null
+++ b/drivers/crypto/keystone-sa-hlp.h
@@ -0,0 +1,399 @@
+/*
+ * Keystone crypto accelerator driver
+ *
+ * Copyright (C) 2015,2016 Texas Instruments Incorporated - http://www.ti.com
+ *
+ * Authors:	Sandeep Nair
+ *		Vitaly Andrianov
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#ifndef _KEYSTONE_SA_HLP_
+#define _KEYSTONE_SA_HLP_
+
+#include <linux/soc/ti/knav_dma.h>
+#include <linux/soc/ti/knav_qmss.h>
+#include <linux/interrupt.h>
+#include <linux/hw_random.h>
+#include <linux/skbuff.h>
+#include <asm/aes_glue.h>
+
+/* Enable the below macro for testing with run-time
+ * self tests in the cryptographic algorithm manager
+ * framework */
+/* #define TEST */
+
+/* For enabling debug prints */
+/* #define DEBUG */
+
+/* Algorithm constants */
+#define MD5_BLOCK_SIZE    64
+#define AES_XCBC_DIGEST_SIZE	16
+
+/* Values for NULL algorithms */
+#define NULL_KEY_SIZE		0
+#define NULL_BLOCK_SIZE	1
+#define NULL_DIGEST_SIZE	0
+#define NULL_IV_SIZE		0
+
+/* Number of 32 bit words in EPIB  */
+#define SA_DMA_NUM_EPIB_WORDS	4
+
+/* Number of 32 bit words in PS data  */
+#define SA_DMA_NUM_PS_WORDS	16
+
+/* Number of meta data elements passed in descriptor to SA */
+#define SA_NUM_DMA_META_ELEMS	2
+
+/* Maximum number of simultaeneous security contexts
+ * supported by the driver */
+#define SA_MAX_NUM_CTX	512
+
+/* Encoding used to identify the typo of crypto operation
+ * performed on the packet when the packet is returned
+ * by SA
+ */
+#define SA_REQ_SUBTYPE_ENC	0x0001
+#define SA_REQ_SUBTYPE_DEC	0x0002
+#define SA_REQ_SUBTYPE_SHIFT	16
+#define SA_REQ_SUBTYPE_MASK	0xffff
+
+/* Maximum size of authentication tag
+ * NOTE: update this macro as we start supporting
+ * algorithms with bigger digest size
+ */
+#define SA_MAX_AUTH_TAG_SZ SHA1_DIGEST_SIZE
+
+/* Memory map of the SA register set */
+struct sa_mmr_regs {
+	u32 PID;
+	u32 RES01;
+	u32 CMD_STATUS;
+	u32 RES02;
+	u32 PA_FLOWID;
+	u32 CDMA_FLOWID;
+	u32 PA_ENG_ID;
+	u32 CDMA_ENG_ID;
+	u8  RSVD0[224];
+	u32 CTXCACH_CTRL;
+	u32 CTXCACH_SC_PTR;
+	u32 CTXCACH_SC_ID;
+	u32 CTXCACH_MISSCNT;
+};
+
+/*
+ * Register Overlay Structure for TRNG module
+ */
+struct sa_trng_regs {
+	u32 TRNG_OUTPUT_L;
+	u32 TRNG_OUTPUT_H;
+	u32 TRNG_STATUS;
+	u32 TRNG_INTMASK;
+	u32 TRNG_INTACK;
+	u32 TRNG_CONTROL;
+	u32 TRNG_CONFIG;
+	u32 RSVD0[228];
+};
+
+struct sa_regs {
+	struct sa_mmr_regs mmr;
+};
+
+/* Driver statistics */
+struct sa_drv_stats {
+	/* Number of data pkts dropped while submitting to CP_ACE */
+	atomic_t tx_dropped;
+	/* Number of tear-down pkts dropped while submitting to CP_ACE */
+	atomic_t sc_tear_dropped;
+	/* Number of crypto requests sent to CP_ACE */
+	atomic_t tx_pkts;
+	/* Number of crypto request completions received from CP_ACE */
+	atomic_t rx_pkts;
+};
+
+/* Crypto driver instance data */
+struct keystone_crypto_data {
+	struct platform_device	*pdev;
+	struct clk		*clk;
+	struct tasklet_struct	rx_task;
+	struct tasklet_struct	tx_task;
+	struct dma_pool		*sc_pool;
+	struct kmem_cache	*dma_req_ctx_cache;
+	struct sa_regs		*regs;
+	struct sa_trng_regs	*trng_regs;
+
+	void		*rx_chan;
+	void		*rx_fdq[KNAV_DMA_FDQ_PER_CHAN];
+	void		*rx_compl_q;
+	void		*tx_chan;
+	void		*tx_submit_q;
+	void		*tx_compl_q;
+	u32		tx_submit_qid;
+	u32		tx_compl_qid;
+	u32		rx_compl_qid;
+	const char	*rx_chan_name;
+	const char	*tx_chan_name;
+	u32		tx_queue_depth;
+	u32		rx_queue_depths[KNAV_DMA_FDQ_PER_CHAN];
+	u32		rx_buffer_sizes[KNAV_DMA_FDQ_PER_CHAN];
+	u32		rx_pool_size;
+	u32		rx_pool_region_id;
+	void		*rx_pool;
+	u32		tx_pool_size;
+	u32		tx_pool_region_id;
+	void		*tx_pool;
+
+	struct hwrng	rng;
+	int		rng_initialized;
+
+	spinlock_t	scid_lock; /* lock for SC-ID allocation */
+	spinlock_t	trng_lock; /* reading random data from TRNG */
+
+	struct kobject	stats_kobj;
+	int		stats_fl;
+
+	/* Security context data */
+	u16		sc_id_start;
+	u16		sc_id_end;
+	u16		sc_id;
+
+	/* Bitmap to keep track of Security context ID's */
+	unsigned long	ctx_bm[DIV_ROUND_UP(SA_MAX_NUM_CTX,
+				BITS_PER_LONG)];
+	/* Driver stats */
+	struct sa_drv_stats	stats;
+	atomic_t	rx_dma_page_cnt; /* N buf from 2nd pool available */
+	atomic_t	tx_dma_desc_cnt; /* Tx DMA desc-s available */
+};
+
+/* Packet structure used in Rx */
+#define SA_SGLIST_SIZE	(MAX_SKB_FRAGS + SA_NUM_DMA_META_ELEMS)
+struct sa_packet {
+	struct scatterlist		 sg[SA_SGLIST_SIZE];
+	int				 sg_ents;
+	struct keystone_crypto_data	*priv;
+	struct dma_chan			*chan;
+	struct dma_async_tx_descriptor	*desc;
+	dma_cookie_t			 cookie;
+	u32				 epib[SA_DMA_NUM_EPIB_WORDS];
+	u32				 psdata[SA_DMA_NUM_PS_WORDS];
+	struct completion		 complete;
+	void				*data;
+};
+
+/* Command label updation info */
+struct sa_cmdl_param_info {
+	u16	index;
+	u16	offset;
+	u16	size;
+};
+
+/* Maximum length of Auxiliary data in 32bit words */
+#define SA_MAX_AUX_DATA_WORDS	8
+
+struct sa_cmdl_upd_info {
+	u16	flags;
+	u16	submode;
+	struct sa_cmdl_param_info	enc_size;
+	struct sa_cmdl_param_info	enc_size2;
+	struct sa_cmdl_param_info	enc_offset;
+	struct sa_cmdl_param_info	enc_iv;
+	struct sa_cmdl_param_info	enc_iv2;
+	struct sa_cmdl_param_info	aad;
+	struct sa_cmdl_param_info	payload;
+	struct sa_cmdl_param_info	auth_size;
+	struct sa_cmdl_param_info	auth_size2;
+	struct sa_cmdl_param_info	auth_offset;
+	struct sa_cmdl_param_info	auth_iv;
+	struct sa_cmdl_param_info	aux_key_info;
+	u32				aux_key[SA_MAX_AUX_DATA_WORDS];
+};
+
+enum sa_submode {
+	SA_MODE_GEN = 0,
+	SA_MODE_CCM,
+	SA_MODE_GCM,
+	SA_MODE_GMAC
+};
+
+/* TFM Context info */
+
+/*
+ * Number of 32bit words appended after the command label
+ * in PSDATA to identify the crypto request context.
+ * word-0: Request type
+ * word-1: pointer to request
+ */
+#define SA_PSDATA_CTX_WORDS 4
+
+/* Maximum size of Command label in 32 words */
+#define SA_MAX_CMDL_WORDS (SA_DMA_NUM_PS_WORDS - SA_PSDATA_CTX_WORDS)
+
+struct sa_ctx_info {
+	u8		*sc;
+	dma_addr_t	sc_phys;
+	u16		sc_id;
+	u16		cmdl_size;
+	u32		cmdl[SA_MAX_CMDL_WORDS];
+	struct sa_cmdl_upd_info cmdl_upd_info;
+	/* Store Auxiliary data such as K2/K3 subkeys in AES-XCBC */
+	u32		epib[SA_DMA_NUM_EPIB_WORDS];
+	u32		rx_flow;
+	u32		rx_compl_qid;
+};
+
+struct sa_tfm_ctx {
+	struct keystone_crypto_data *dev_data;
+	struct sa_ctx_info enc;
+	struct sa_ctx_info dec;
+	struct sa_ctx_info auth;
+};
+
+/* Tx DMA callback param */
+struct sa_dma_req_ctx {
+	struct keystone_crypto_data *dev_data;
+	u32		cmdl[SA_MAX_CMDL_WORDS + SA_PSDATA_CTX_WORDS];
+	unsigned	map_idx;
+	struct sg_table sg_tbl;
+	dma_cookie_t	cookie;
+	struct dma_chan *tx_chan;
+	bool		pkt;
+};
+
+/* Encryption algorithms */
+enum sa_ealg_id {
+	SA_EALG_ID_NONE = 0,        /* No encryption */
+	SA_EALG_ID_NULL,            /* NULL encryption */
+	SA_EALG_ID_AES_CTR,         /* AES Counter mode */
+	SA_EALG_ID_AES_F8,          /* AES F8 mode */
+	SA_EALG_ID_AES_CBC,         /* AES CBC mode */
+	SA_EALG_ID_DES_CBC,         /* DES CBC mode */
+	SA_EALG_ID_3DES_CBC,        /* 3DES CBC mode */
+	SA_EALG_ID_CCM,             /* Counter with CBC-MAC mode */
+	SA_EALG_ID_GCM,             /* Galois Counter mode */
+	SA_EALG_ID_LAST
+};
+
+/* Authentication algorithms */
+enum sa_aalg_id {
+	SA_AALG_ID_NONE = 0,               /* No Authentication  */
+	SA_AALG_ID_NULL = SA_EALG_ID_LAST, /* NULL Authentication  */
+	SA_AALG_ID_MD5,                    /* MD5 mode */
+	SA_AALG_ID_SHA1,                   /* SHA1 mode */
+	SA_AALG_ID_SHA2_224,               /* 224-bit SHA2 mode */
+	SA_AALG_ID_SHA2_256,               /* 256-bit SHA2 mode */
+	SA_AALG_ID_HMAC_MD5,               /* HMAC with MD5 mode */
+	SA_AALG_ID_HMAC_SHA1,              /* HMAC with SHA1 mode */
+	SA_AALG_ID_HMAC_SHA2_224,          /* HMAC with 224-bit SHA2 mode */
+	SA_AALG_ID_HMAC_SHA2_256,          /* HMAC with 256-bit SHA2 mode */
+	SA_AALG_ID_GMAC,                   /* Galois Message
+					      Authentication Code mode */
+	SA_AALG_ID_CMAC,                   /* Cipher-based Message
+					      Authentication Code mode */
+	SA_AALG_ID_CBC_MAC,                /* Cipher Block Chaining */
+	SA_AALG_ID_AES_XCBC                /* AES Extended
+					      Cipher Block Chaining */
+};
+
+/* Mode control engine algorithms used to index the
+ * mode control instruction tables
+ */
+enum sa_eng_algo_id {
+	SA_ENG_ALGO_ECB = 0,
+	SA_ENG_ALGO_CBC,
+	SA_ENG_ALGO_CFB,
+	SA_ENG_ALGO_OFB,
+	SA_ENG_ALGO_CTR,
+	SA_ENG_ALGO_F8,
+	SA_ENG_ALGO_F8F9,
+	SA_ENG_ALGO_GCM,
+	SA_ENG_ALGO_GMAC,
+	SA_ENG_ALGO_CCM,
+	SA_ENG_ALGO_CMAC,
+	SA_ENG_ALGO_CBCMAC,
+	SA_NUM_ENG_ALGOS
+};
+
+/* 3DES only supports ECB, CBC, CFB and OFB. */
+#define SA_3DES_FIRST_ALGO          SA_ENG_ALGO_ECB
+#define SA_3DES_LAST_ALGO           SA_ENG_ALGO_OFB
+#define SA_3DES_NUM_ALGOS           (SA_3DES_LAST_ALGO - SA_3DES_FIRST_ALGO + 1)
+
+#define NKEY_SZ			3
+#define MCI_SZ			27
+
+struct sa_eng_info {
+	u8	eng_id;
+	u16	sc_size;
+};
+
+#define DMA_HAS_PSINFO		BIT(31)
+#define DMA_HAS_EPIB		BIT(30)
+
+void sa_register_algos(const struct device *dev);
+void sa_unregister_algos(const struct device *dev);
+void sa_tx_completion_process(struct keystone_crypto_data *dev_data);
+void sa_rx_completion_process(struct keystone_crypto_data *dev_data);
+
+void sa_set_sc_auth(u16 alg_id, const u8 *key, u16 key_sz, u8 *sc_buf);
+int sa_set_sc_enc(u16 alg_id, const u8 *key, u16 key_sz,
+		  u16 aad_len, u8 enc, u8 *sc_buf);
+
+void sa_swiz_128(u8 *in, u8 *out, u16 len);
+void sa_conv_calg_to_salg(const char *cra_name, int *ealg_id, int *aalg_id);
+void sa_get_engine_info(int alg_id, struct sa_eng_info *info);
+int sa_get_hash_size(u16 aalg_id);
+
+/*
+ * Derive sub-key k1, k2 and k3 used in the AES XCBC MAC mode
+ * detailed in RFC 3566
+ */
+static inline int sa_aes_xcbc_subkey(u8 *sub_key1, u8 *sub_key2,
+				     u8 *sub_key3, const u8 *key,
+				     u16 key_sz)
+{
+	struct AES_KEY enc_key;
+
+	if (private_AES_set_encrypt_key(key, (key_sz * 8), &enc_key) == -1) {
+		pr_err("%s: failed to set enc key\n", __func__);
+		return -1;
+	}
+
+	if (sub_key1) {
+		memset(sub_key1, 0x01, AES_BLOCK_SIZE);
+		AES_encrypt(sub_key1, sub_key1, &enc_key);
+	}
+
+	if (sub_key2) {
+		memset(sub_key2, 0x02, AES_BLOCK_SIZE);
+		AES_encrypt(sub_key2, sub_key2, &enc_key);
+	}
+
+	if (sub_key3) {
+		memset(sub_key3, 0x03, AES_BLOCK_SIZE);
+		AES_encrypt(sub_key3, sub_key3, &enc_key);
+	}
+
+	return 0;
+}
+
+struct sa_eng_mci_tbl {
+	uint8_t aes_enc[SA_NUM_ENG_ALGOS][NKEY_SZ][MCI_SZ];
+	uint8_t aes_dec[SA_NUM_ENG_ALGOS][NKEY_SZ][MCI_SZ];
+	uint8_t _3des_enc[SA_3DES_NUM_ALGOS][MCI_SZ];
+	uint8_t _3des_dec[SA_3DES_NUM_ALGOS][MCI_SZ];
+};
+
+extern struct sa_eng_mci_tbl sa_mci_tbl;
+
+extern struct device *sa_ks2_dev;
+
+#endif /* _KEYSTONE_SA_HLP_ */
diff --git a/drivers/crypto/keystone-sa-lld.c b/drivers/crypto/keystone-sa-lld.c
new file mode 100644
index 0000000..ffd4677
--- /dev/null
+++ b/drivers/crypto/keystone-sa-lld.c
@@ -0,0 +1,429 @@
+/*
+ * Keystone crypto accelerator driver
+ *
+ * Copyright (C) 2015, 2016 Texas Instruments Incorporated - http://www.ti.com
+ *
+ * Authors:	Sandeep Nair
+ *		Vitaly Andrianov
+ *
+ * Contributors:Tinku Mannan
+ *		Hao Zhang
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/crypto.h>
+#include <linux/cryptohash.h>
+
+#include <crypto/algapi.h>
+#include <crypto/aead.h>
+#include <crypto/authenc.h>
+#include <crypto/hash.h>
+#include <crypto/internal/hash.h>
+#include <crypto/aes.h>
+#include <crypto/des.h>
+#include <crypto/sha.h>
+#include <crypto/md5.h>
+
+#include "keystone-sa.h"
+#include "keystone-sa-hlp.h"
+
+/* Byte offset for key in encryption security context */
+#define SC_ENC_KEY_OFFSET (1 + 27 + 4)
+/* Byte offset for Aux-1 in encryption security context */
+#define SC_ENC_AUX1_OFFSET (1 + 27 + 4 + 32)
+
+struct sa_eng_mci_tbl sa_mci_tbl;
+
+/* Perform 16 byte swizzling */
+void sa_swiz_128(u8 *in, u8 *out, u16 len)
+{
+	u8 data[16];
+	int i, j;
+
+	for (i = 0; i < len; i += 16) {
+		memcpy(data, &in[i], 16);
+		for (j = 0; j < 16; j++)
+			out[i + j] = data[15 - j];
+	}
+}
+
+/* Convert CRA name to internal algorithm ID */
+void sa_conv_calg_to_salg(const char *cra_name, int *ealg_id, int *aalg_id)
+{
+	*ealg_id = SA_EALG_ID_NONE;
+	*aalg_id = SA_AALG_ID_NONE;
+
+	if (!strcmp(cra_name, "authenc(hmac(sha1),cbc(aes))")) {
+		*ealg_id = SA_EALG_ID_AES_CBC;
+		*aalg_id = SA_AALG_ID_HMAC_SHA1;
+	} else if (!strcmp(cra_name, "authenc(hmac(sha1),ecb(cipher_null))")) {
+		*ealg_id = SA_EALG_ID_NULL;
+		*aalg_id = SA_AALG_ID_HMAC_SHA1;
+	} else if (!strcmp(cra_name, "authenc(hmac(sha1),cbc(des3_ede))")) {
+		*ealg_id = SA_EALG_ID_3DES_CBC;
+		*aalg_id = SA_AALG_ID_HMAC_SHA1;
+	} else if (!strcmp(cra_name, "authenc(xcbc(aes),cbc(aes))")) {
+		*ealg_id = SA_EALG_ID_AES_CBC;
+		*aalg_id = SA_AALG_ID_AES_XCBC;
+	} else if (!strcmp(cra_name, "authenc(xcbc(aes),cbc(des3_ede))")) {
+		*ealg_id = SA_EALG_ID_3DES_CBC;
+		*aalg_id = SA_AALG_ID_AES_XCBC;
+	} else if (!strcmp(cra_name, "cbc(aes)")) {
+		*ealg_id = SA_EALG_ID_AES_CBC;
+	} else if (!strcmp(cra_name, "cbc(des3_ede)")) {
+		*ealg_id = SA_EALG_ID_3DES_CBC;
+	} else if (!strcmp(cra_name, "hmac(sha1)")) {
+		*aalg_id = SA_AALG_ID_HMAC_SHA1;
+	} else if (!strcmp(cra_name, "xcbc(aes)")) {
+		*aalg_id = SA_AALG_ID_AES_XCBC;
+	}
+}
+
+/* Given an algorithm ID get the engine details */
+void sa_get_engine_info(int alg_id, struct sa_eng_info *info)
+{
+	switch (alg_id) {
+	case SA_EALG_ID_AES_CBC:
+	case SA_EALG_ID_3DES_CBC:
+	case SA_EALG_ID_DES_CBC:
+		info->eng_id = SA_ENG_ID_EM1;
+		info->sc_size = SA_CTX_ENC_TYPE1_SZ;
+		break;
+
+	case SA_EALG_ID_NULL:
+		info->eng_id = SA_ENG_ID_NONE;
+		info->sc_size = 0;
+		break;
+
+	case SA_AALG_ID_HMAC_SHA1:
+	case SA_AALG_ID_HMAC_MD5:
+		info->eng_id = SA_ENG_ID_AM1;
+		info->sc_size = SA_CTX_AUTH_TYPE2_SZ;
+		break;
+
+	case SA_AALG_ID_AES_XCBC:
+	case SA_AALG_ID_CMAC:
+		info->eng_id = SA_ENG_ID_EM1;
+		info->sc_size = SA_CTX_AUTH_TYPE1_SZ;
+		break;
+
+	default:
+		pr_err("%s: unsupported algo\n", __func__);
+		info->eng_id = SA_ENG_ID_NONE;
+		info->sc_size = 0;
+		break;
+	}
+}
+
+/* Given an algorithm get the hash size */
+int sa_get_hash_size(u16 aalg_id)
+{
+	int hash_size = 0;
+
+	switch (aalg_id) {
+	case SA_AALG_ID_MD5:
+	case SA_AALG_ID_HMAC_MD5:
+		hash_size = MD5_DIGEST_SIZE;
+		break;
+
+	case SA_AALG_ID_SHA1:
+	case SA_AALG_ID_HMAC_SHA1:
+		hash_size = SHA1_DIGEST_SIZE;
+		break;
+
+	case SA_AALG_ID_SHA2_224:
+	case SA_AALG_ID_HMAC_SHA2_224:
+		hash_size = SHA224_DIGEST_SIZE;
+		break;
+
+	case SA_AALG_ID_SHA2_256:
+	case SA_AALG_ID_HMAC_SHA2_256:
+		hash_size = SHA256_DIGEST_SIZE;
+		break;
+
+	case SA_AALG_ID_AES_XCBC:
+	case SA_AALG_ID_CMAC:
+		hash_size = AES_BLOCK_SIZE;
+		break;
+
+	default:
+		pr_err("%s: unsupported hash\n", __func__);
+		break;
+	}
+
+	return hash_size;
+}
+
+/* Initialize MD5 digest */
+static inline void md5_init(u32 *hash)
+{
+	/* Load magic initialization constants */
+	hash[0] = 0x67452301;
+	hash[1] = 0xefcdab89;
+	hash[2] = 0x98badcfe;
+	hash[3] = 0x10325476;
+}
+
+/* Generate HMAC-MD5 intermediate Hash */
+static void sa_hmac_md5_get_pad(const u8 *key, u16 key_sz, u32 *ipad, u32 *opad)
+{
+	u8 k_ipad[MD5_MESSAGE_BYTES];
+	u8 k_opad[MD5_MESSAGE_BYTES];
+	int i;
+
+	for (i = 0; i < key_sz; i++) {
+		k_ipad[i] = key[i] ^ 0x36;
+		k_opad[i] = key[i] ^ 0x5c;
+	}
+	/* Instead of XOR with 0 */
+	for (; i < SHA_MESSAGE_BYTES; i++) {
+		k_ipad[i] = 0x36;
+		k_opad[i] = 0x5c;
+	}
+
+	/* SHA-1 on k_ipad */
+	md5_init(ipad);
+	md5_transform(ipad, (u32 *)k_ipad);
+
+	/* SHA-1 on k_opad */
+	md5_init(opad);
+	md5_transform(ipad, (u32 *)k_opad);
+}
+
+/* Generate HMAC-SHA1 intermediate Hash */
+static
+void sa_hmac_sha1_get_pad(const u8 *key, u16 key_sz, u32 *ipad, u32 *opad)
+{
+	u32 ws[SHA_WORKSPACE_WORDS];
+	u8 k_ipad[SHA_MESSAGE_BYTES];
+	u8 k_opad[SHA_MESSAGE_BYTES];
+	int i;
+
+	for (i = 0; i < key_sz; i++) {
+		k_ipad[i] = key[i] ^ 0x36;
+		k_opad[i] = key[i] ^ 0x5c;
+	}
+	/* Instead of XOR with 0 */
+	for (; i < SHA_MESSAGE_BYTES; i++) {
+		k_ipad[i] = 0x36;
+		k_opad[i] = 0x5c;
+	}
+
+	/* SHA-1 on k_ipad */
+	sha_init(ipad);
+	sha_transform(ipad, k_ipad, ws);
+
+	for (i = 0; i < SHA_DIGEST_WORDS; i++)
+		ipad[i] = cpu_to_be32(ipad[i]);
+
+	/* SHA-1 on k_opad */
+	sha_init(opad);
+	sha_transform(opad, k_opad, ws);
+
+	for (i = 0; i < SHA_DIGEST_WORDS; i++)
+		opad[i] = cpu_to_be32(opad[i]);
+}
+
+/* Derive the inverse key used in AES-CBC decryption operation */
+static inline int sa_aes_inv_key(u8 *inv_key, const u8 *key, u16 key_sz)
+{
+	struct crypto_aes_ctx ctx;
+	int key_pos;
+
+	if (crypto_aes_expand_key(&ctx, key, key_sz)) {
+		pr_err("%s: bad key len(%d)\n", __func__, key_sz);
+		return -1;
+	}
+
+	/* Refer the implementation of crypto_aes_expand_key()
+	 * to understand the below logic
+	 */
+	switch (key_sz) {
+	case AES_KEYSIZE_128:
+	case AES_KEYSIZE_192:
+		key_pos = key_sz + 24;
+		break;
+
+	case AES_KEYSIZE_256:
+		key_pos = key_sz + 24 - 4;
+		break;
+
+	default:
+		pr_err("%s: bad key len(%d)\n", __func__, key_sz);
+		return -1;
+	}
+
+	memcpy(inv_key, &ctx.key_enc[key_pos], key_sz);
+	return 0;
+}
+
+/* Set Security context for the encryption engine */
+int sa_set_sc_enc(u16 alg_id, const u8 *key, u16 key_sz,
+		  u16 aad_len, u8 enc, u8 *sc_buf)
+{
+	u8 ghash[16]; /* AES block size */
+	const u8 *mci = NULL;
+	/* Convert the key size (16/24/32) to the key size index (0/1/2) */
+	int key_idx = (key_sz >> 3) - 2;
+
+	/* Set Encryption mode selector to crypto processing */
+	sc_buf[0] = 0;
+
+	/* Select the mode control instruction */
+	switch (alg_id) {
+	case SA_EALG_ID_AES_CBC:
+		mci = (enc) ? sa_mci_tbl.aes_enc[SA_ENG_ALGO_CBC][key_idx] :
+			sa_mci_tbl.aes_dec[SA_ENG_ALGO_CBC][key_idx];
+		break;
+
+	case SA_EALG_ID_CCM:
+		mci = (enc) ? sa_mci_tbl.aes_enc[SA_ENG_ALGO_CCM][key_idx] :
+			sa_mci_tbl.aes_dec[SA_ENG_ALGO_CCM][key_idx];
+		break;
+
+	case SA_EALG_ID_AES_F8:
+		mci = sa_mci_tbl.aes_enc[SA_ENG_ALGO_F8][key_idx];
+		break;
+
+	case SA_EALG_ID_AES_CTR:
+		mci = sa_mci_tbl.aes_enc[SA_ENG_ALGO_CTR][key_idx];
+		break;
+
+	case SA_EALG_ID_GCM:
+		mci = (enc) ? sa_mci_tbl.aes_enc[SA_ENG_ALGO_GCM][key_idx] :
+			sa_mci_tbl.aes_dec[SA_ENG_ALGO_GCM][key_idx];
+		/* Set AAD length at byte offset 23 in Aux-1 */
+		sc_buf[SC_ENC_AUX1_OFFSET + 23] = (aad_len << 3);
+		/* fall through to GMAC */
+
+	case SA_AALG_ID_GMAC:
+		/* copy GCM Hash in Aux-1 */
+		memcpy(&sc_buf[SC_ENC_AUX1_OFFSET], ghash, 16);
+		break;
+
+	case SA_AALG_ID_AES_XCBC:
+	case SA_AALG_ID_CMAC:
+		mci = sa_mci_tbl.aes_enc[SA_ENG_ALGO_CMAC][key_idx];
+		break;
+
+	case SA_AALG_ID_CBC_MAC:
+		mci = sa_mci_tbl.aes_enc[SA_ENG_ALGO_CBCMAC][key_idx];
+		break;
+
+	case SA_EALG_ID_3DES_CBC:
+		mci = (enc) ? sa_mci_tbl._3des_enc[SA_ENG_ALGO_CBC] :
+			sa_mci_tbl._3des_dec[SA_ENG_ALGO_CBC];
+		break;
+	}
+
+	/* Set the mode control instructions in security context */
+	if (mci)
+		memcpy(&sc_buf[1], mci, 27);
+
+	/* For AES-CBC decryption get the inverse key */
+	if ((alg_id == SA_EALG_ID_AES_CBC) && !enc) {
+		if (sa_aes_inv_key(&sc_buf[SC_ENC_KEY_OFFSET], key, key_sz))
+			return -1;
+	}
+	/* For AES-XCBC-MAC get the subkey */
+	else if (alg_id == SA_AALG_ID_AES_XCBC) {
+		if (sa_aes_xcbc_subkey(&sc_buf[SC_ENC_KEY_OFFSET], NULL,
+				       NULL, key, key_sz))
+			return -1;
+	}
+	/* For all other cases: key is used */
+	else
+		memcpy(&sc_buf[SC_ENC_KEY_OFFSET], key, key_sz);
+
+	return 0;
+}
+
+/* Set Security context for the authentication engine */
+void sa_set_sc_auth(u16 alg_id, const u8 *key, u16 key_sz, u8 *sc_buf)
+{
+	u32 ipad[8], opad[8];
+	u8 mac_sz, keyed_mac = 0;
+
+	/* Set Authentication mode selector to hash processing */
+	sc_buf[0] = 0;
+
+	/* Auth SW ctrl word: bit[6]=1 (upload computed hash to TLR section) */
+	sc_buf[1] = 0x40;
+
+	switch (alg_id) {
+	case SA_AALG_ID_MD5:
+		/* Auth SW ctrl word: bit[4]=1 (basic hash)
+		 * bit[3:0]=1 (MD5 operation)*/
+		sc_buf[1] |= (0x10 | 0x1);
+		break;
+
+	case SA_AALG_ID_SHA1:
+		/* Auth SW ctrl word: bit[4]=1 (basic hash)
+		 * bit[3:0]=2 (SHA1 operation)*/
+		sc_buf[1] |= (0x10 | 0x2);
+		break;
+
+	case SA_AALG_ID_SHA2_224:
+		/* Auth SW ctrl word: bit[4]=1 (basic hash)
+		 * bit[3:0]=3 (SHA2-224 operation)*/
+		sc_buf[1] |= (0x10 | 0x3);
+		break;
+
+	case SA_AALG_ID_SHA2_256:
+		/* Auth SW ctrl word: bit[4]=1 (basic hash)
+		 * bit[3:0]=4 (SHA2-256 operation)*/
+		sc_buf[1] |= (0x10 | 0x4);
+		break;
+
+	case SA_AALG_ID_HMAC_MD5:
+		/* Auth SW ctrl word: bit[4]=0 (HMAC)
+		 * bit[3:0]=1 (MD5 operation)*/
+		sc_buf[1] |= 0x1;
+		keyed_mac = 1;
+		mac_sz = MD5_DIGEST_SIZE;
+		sa_hmac_md5_get_pad(key, key_sz, ipad, opad);
+		break;
+
+	case SA_AALG_ID_HMAC_SHA1:
+		/* Auth SW ctrl word: bit[4]=0 (HMAC)
+		 * bit[3:0]=2 (SHA1 operation)*/
+		sc_buf[1] |= 0x2;
+		keyed_mac = 1;
+		mac_sz = SHA1_DIGEST_SIZE;
+		sa_hmac_sha1_get_pad(key, key_sz, ipad, opad);
+		break;
+
+	case SA_AALG_ID_HMAC_SHA2_224:
+		/* Auth SW ctrl word: bit[4]=0 (HMAC)
+		 * bit[3:0]=3 (SHA2-224 operation)*/
+		sc_buf[1] |= 0x3;
+		keyed_mac = 1;
+		mac_sz = SHA224_DIGEST_SIZE;
+		break;
+
+	case SA_AALG_ID_HMAC_SHA2_256:
+		/* Auth SW ctrl word: bit[4]=0 (HMAC)
+		 * bit[3:0]=4 (SHA2-256 operation)*/
+		sc_buf[1] |= 0x4;
+		keyed_mac = 1;
+		mac_sz = SHA256_DIGEST_SIZE;
+		break;
+	}
+
+	/* Copy the keys or ipad/opad */
+	if (keyed_mac) {
+		/* Copy ipad to AuthKey */
+		memcpy(&sc_buf[32], ipad, mac_sz);
+		/* Copy opad to Aux-1 */
+		memcpy(&sc_buf[64], opad, mac_sz);
+	}
+}
diff --git a/drivers/crypto/keystone-sa.h b/drivers/crypto/keystone-sa.h
new file mode 100644
index 0000000..ee06a15
--- /dev/null
+++ b/drivers/crypto/keystone-sa.h
@@ -0,0 +1,327 @@
+/*
+ * Keystone crypto accelerator driver
+ *
+ * Copyright (C) 2013-2016 Texas Instruments Incorporated - http://www.ti.com
+ * Contact: Sandeep Nair <sandeep_n@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+/*
+ *
+ *     0                   1                   2                   3
+ *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -----
+ *   |                                                               |
+ *   |   Software only section (not fetched by CP_ACE)               |
+ *   |               (optional)                                      |
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<-Must be
+ *   |               SCCTL                                           |  64 byte
+ *   |               (8 bytes)                                       |  aligned
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |                                                               |
+ *   |   PHP module specific section (fetched by CP_ACE)             |
+ *   |               (56 bytes)                                      |
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -----
+ *   |                                                               |
+ *   |   Encryption module specific section (fetched by CP_ACE)      |
+ *   |               (variable size)                                 |
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<-64 byte
+ *   |                                                               |  aligned
+ *   |   Authentication module specific section (fetched by CP_ACE)  |
+ *   |               (variable size)                                 |
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -----
+ *
+ *              Figure: Security Context memory layout
+ *
+ *
+ *     0                   1                   2                   3
+ *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -----
+ *   |O|Evict done   |  F/E control  |           SCID                |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   |                 SCPTR (Security Context Pointer)              |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -----
+ *              O : Owner
+ *              SCID & SCPTR are filled by hardware
+ *              Figure: Security Context control word (SCCTL)
+ *
+ *
+ *     0                   1                   2                   3
+ *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |D|  Pkt Type   |  Flow Index   |   Dest Queue ID               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |               SWINFO-0 (4 bytes)                              |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |               SWINFO-1 (4 bytes)                              |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   | PktID (16 bits)               |                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |                                                               |
+ *   |                Protocol Specific Parameters                   |
+ *   |                (Variable Size up to 116 bytes                 |
+ *   ...                                                           ...
+ *   |                                                               |
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *              D : Direction
+ *              Figure: PHP engine Security Context Format
+ *
+ *
+ *     0                   1                   2                   3
+ *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |M| R |nEngineID|                                               |
+ *   +-+-+-+-+-+-+-+-+                                               +
+ *   |                  encryption mode ctrl word                    |
+ *   ...                                                           ...
+ *   |                       (27 bytes)                              |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Reserved (4 bytes) (must initialize to 0)            |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Encryption Key value (32 bytes)                      |
+ *   ...                                                           ...
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Encryption Aux-1 (32 bytes) (optional)               |
+ *   ...                                                           ...
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Encryption Aux-2 (16 bytes) (optional)               |
+ *   ...                                                           ...
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Encryption Aux-3 (16 bytes) (optional)               |
+ *   ...                                                           ...
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Encryption Aux-4 (16 bytes)                          |
+ *   ...                                                           ...
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Pre-crypto data store (15 bytes)                     |
+ *   |                                                               |
+ *   |                                               +-+-+-+-+-+-+-+-|
+ *   |                                               |               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *              M : Encryption Mode selector (0=crypto processing, 1=NULL)
+ *              R : Reserved
+ *              Figure: Encryption engine Security Context Format
+ *
+ *
+ *     0                   1                   2                   3
+ *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |M| R |nEngineID| Auth SW Ctrl  |                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
+ *   |                  Reserved (6 bytes)                           |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Authentication length (8 bytes)                      |
+ *   |          ( 0 = let h/w calculate the length )                 |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Reserved (12 bytes)                                  |
+ *   ...                                                           ...
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          HW crtl word (4 bytes) must be set to 0 by SW        |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Authentication Key value (32 bytes)                  |
+ *   ...        Master Key or pre-computed inner digest for HMAC   ...
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Authentication Aux-1 (32 bytes) (optional)           |
+ *   ...        Pre-computed outer opad for HMAC                   ...
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Authentication Aux-2 (32 bytes) (optional)           |
+ *   ...                                                           ...
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Pre-crypto data store (32 bytes)                     |
+ *   ...        ( HW access only)                                   ...
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *   |          Pre-crypto data store (32 bytes)                     |
+ *   ...        ( HW access only)                                   ...
+ *   |                                                               |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ------
+ *              M : Authentication Mode selector (0=hash processing, 1=NULL)
+ *              R : Reserved
+ *              Figure: Authentication engine Security Context Format
+ *
+ */
+
+#ifndef _KEYSTONE_SA_H_
+#define _KEYSTONE_SA_H_
+
+/*
+ * This type represents the various packet types to be processed
+ * by the PHP engine in SA.
+ * It is used to identify the corresponding PHP processing function.
+ */
+typedef u8 SA_CTX_PE_PKT_TYPE_T;
+#define SA_CTX_PE_PKT_TYPE_3GPP_AIR    0    /* 3GPP Air Cipher */
+#define SA_CTX_PE_PKT_TYPE_SRTP        1    /* SRTP */
+#define SA_CTX_PE_PKT_TYPE_IPSEC_AH    2    /* IPSec Authentication Header */
+#define SA_CTX_PE_PKT_TYPE_IPSEC_ESP   3    /* IPSec Encapsulating
+					       Security Payload */
+#define SA_CTX_PE_PKT_TYPE_NONE        4    /* Indicates that it is in
+					       data mode, It may not be
+					       used by PHP */
+
+#define SA_CTX_ENC_TYPE1_SZ	64	/* Encryption SC with Key only */
+#define SA_CTX_ENC_TYPE2_SZ	96	/* Encryption SC with Key and Aux1 */
+
+#define SA_CTX_AUTH_TYPE1_SZ	64	/* Auth SC with Key only */
+#define SA_CTX_AUTH_TYPE2_SZ	96	/* Auth SC with Key and Aux1 */
+
+#define SA_CTX_PHP_PE_CTX_SZ	64	/* Size of security ctx for
+					   PHP engine */
+
+#define SA_CTX_MAX_SZ (64 + SA_CTX_ENC_TYPE2_SZ + SA_CTX_AUTH_TYPE2_SZ)
+
+/*
+ * Encoding of F/E control in SCCTL
+ *  Bit 0-1: Fetch PHP Bytes
+ *  Bit 2-3: Fetch Encryption/Air Ciphering Bytes
+ *  Bit 4-5: Fetch Authentication Bytes or Encr pass 2
+ *  Bit 6-7: Evict PHP Bytes
+ *
+ *  where   00 = 0 bytes
+ *          01 = 64 bytes
+ *          10 = 96 bytes
+ *          11 = 128 bytes
+ */
+#define SA_CTX_DMA_SIZE_0       0
+#define SA_CTX_DMA_SIZE_64      1
+#define SA_CTX_DMA_SIZE_96      2
+#define SA_CTX_DMA_SIZE_128     3
+
+#define SA_CTX_SCCTL_MK_DMA_INFO(php_f, eng0_f, eng1_f, php_e) \
+	((php_f) | \
+	 ((eng0_f) << 2) | \
+	 ((eng1_f) << 4) | \
+	 ((php_e) << 6))
+
+/*
+ * Byte offset of the owner word in SCCTL
+ * in the security context
+ */
+#define SA_CTX_SCCTL_OWNER_OFFSET 0
+
+/*
+ * Assumption: CTX size is multiple of 32
+ */
+#define SA_CTX_SIZE_TO_DMA_SIZE(ctx_sz)	\
+	((ctx_sz) ? ((ctx_sz) / 32 - 1) : 0)
+
+#define SA_CTX_ENC_KEY_OFFSET	32
+#define SA_CTX_ENC_AUX1_OFFSET	64
+#define SA_CTX_ENC_AUX2_OFFSET	96
+#define SA_CTX_ENC_AUX3_OFFSET	112
+#define SA_CTX_ENC_AUX4_OFFSET	128
+
+/* Next Engine Select code in CP_ACE */
+#define SA_ENG_ID_EM1	2	/*  Encryption/Decryption engine
+				    with AES/DES core */
+#define SA_ENG_ID_EM2	3	/*  Encryption/Decryption enginefor pass 2 */
+#define SA_ENG_ID_AM1	4	/*  Authentication engine with
+				    SHA1/MD5/SHA2 core */
+#define SA_ENG_ID_AM2	5	/*  Authentication engine for pass 2 */
+#define SA_ENG_ID_OUTPORT2 20	/*  Egress module 2  */
+#define SA_ENG_ID_NONE  0xff
+
+/*
+ * Command Label Definitions
+ */
+#define SA_CMDL_OFFSET_NESC           0      /* Next Engine Select Code */
+#define SA_CMDL_OFFSET_LABEL_LEN      1      /* Engine Command Label Length */
+#define SA_CMDL_OFFSET_DATA_LEN       2      /* 16-bit Length of Data to be
+						processed */
+#define SA_CMDL_OFFSET_DATA_OFFSET    4      /* Stat Data Offset */
+#define SA_CMDL_OFFSET_OPTION_CTRL1   5      /* Option Control Byte 1 */
+#define SA_CMDL_OFFSET_OPTION_CTRL2   6      /* Option Control Byte 2 */
+#define SA_CMDL_OFFSET_OPTION_CTRL3   7      /* Option Control Byte 3 */
+#define SA_CMDL_OFFSET_OPTION_BYTE    8
+
+#define SA_CMDL_HEADER_SIZE_BYTES          8
+
+#define SA_CMDL_OPTION_BYTES_MAX_SIZE     72
+#define SA_CMDL_MAX_SIZE_BYTES (SA_CMDL_HEADER_SIZE_BYTES + \
+				SA_CMDL_OPTION_BYTES_MAX_SIZE)
+
+/* SWINFO word-0 flags */
+#define SA_SW_INFO_FLAG_EVICT	0x0001
+#define SA_SW_INFO_FLAG_TEAR	0x0002
+#define SA_SW_INFO_FLAG_NOPD	0x0004
+
+/*
+ * TRNG module definitions
+ */
+
+/* Offset to TRNG module in CP_ACE memory map */
+#define SA_REG_MAP_TRNG_OFFSET	0x24000
+
+/* TRNG enable control in CP_ACE */
+#define SA_CMD_STATUS_REG_TRNG_ENABLE	BIT(3)
+
+/* TRNG start control in TRNG module */
+#define SA_TRNG_CONTROL_REG_TRNG_ENABLE	BIT(10)
+
+/* Data ready indicator in STATUS register */
+#define SA_TRNG_STATUS_REG_READY BIT(0)
+
+/* Data ready clear control in INTACK register */
+#define SA_TRNG_INTACK_REG_READY BIT(0)
+
+/* Number of samples taken to gather entropy during startup.
+ * If value is 0, the number of samples is 2^24 else
+ * equals value times 2^8.
+ */
+#define SA_TRNG_DEF_STARTUP_CYCLES	0
+#define SA_TRNG_CONTROL_REG_STARTUP_CYCLES_SHIFT 16
+
+/* Minimum number of samples taken to regenerate entropy
+ * If value is 0, the number of samples is 2^24 else
+ * equals value times 2^6.
+ */
+#define SA_TRNG_DEF_MIN_REFILL_CYCLES	1
+#define SA_TRNG_CONFIG_REG_MIN_REFILL_CYCLES_SHIFT 0
+
+/* Maximum number of samples taken to regenerate entropy
+ * If value is 0, the number of samples is 2^24 else
+ * equals value times 2^8.
+ */
+#define SA_TRNG_DEF_MAX_REFILL_CYCLES	0
+#define SA_TRNG_CONFIG_REG_MAX_REFILL_CYCLES_SHIFT 16
+
+/* Number of CLK input cycles between samples */
+#define SA_TRNG_DEF_CLK_DIV_CYCLES	0
+#define SA_TRNG_CONFIG_REG_SAMPLE_DIV_SHIFT 8
+
+#define SA_CMD_ENCSS_EN		0x00000001
+#define SA_CMD_AUTHSS_EN	0x00000002
+#define SA_CMD_AIRSS_EN		0x00000004
+#define SA_CMD_TRNG_EN		0x00000008
+#define SA_CMD_PKA_EN		0x00000010
+#define SA_CMD_PHP1SS_EN	0x00000020
+#define SA_CMD_PHP2SS_EN	0x00000040
+#define SA_CMD_CTXCACH_EN	0x00000080
+#define SA_CMD_SA1_IN_EN	0x00000100
+#define SA_CMD_SA0_IN_EN	0x00000200
+#define SA_CMD_SA1_OUT_EN	0x00000400
+#define SA_CMD_SA0_OUT_EN	0x00000800
+
+#endif
-- 
1.9.1

